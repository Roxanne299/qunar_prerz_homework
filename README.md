# qunar_prerz_homework
## qunar入职作业
**答题说明：**自学作业共 5 题，Java 开发工程师需全部完成，测试/逆向开发工程师选 3

题完成即可。

**一、用 Java 写一个 HTTP 服务端**

使用 Java 原生代码（不使用 HttpClient 等高级库）实现一个极简版 HTTP 服务端

**要求：**

1．支持浏览器访问 /hello 返回 Hello, World!

2．支持 GET 和 POST 请求（返回不同消息）

3．能输出请求中的 Header 和 Body

4．支持 404 响应逻辑

**进阶要求：**

添加日志输出：记录请求时间、IP、路径、UA

可支持并发访问（用线程池处理 Socket）

支持简单的 Content-Type 判别和 Keep-Alive

**考察点：**

HTTP 请求结构（方法、路径、协议、头、体）

Java BIO/NIO 服务端开发

多线程 Socket 编程

状态码 / MIME 类型 / 连接控制

**二、基于 Sentinel 的高并发限流熔断服务设计**

你负责的接口 /api/data/process 是一个核心业务 API。最近由于访问量激增，系统频繁

出现延迟甚至异常。为了提升系统稳定性，请你接入 Sentinel 对该接口进行限流与熔断保

护。

**开发任务：**

使用 Spring Boot + Sentinel 完成以下功能：

1、接口实现

创建一个 REST 接口 /api/data/process

模拟业务逻辑处理，延迟 100ms~300ms 之间随机耗时

每次请求随机返回成功或抛出异常（模拟不稳定服务）

2、Sentinel 限流功能实现（重点）

为该接口配置 QPS 限流，最多允许每秒 5 次访问

超过限流时返回友好的提示（如 JSON：服务繁忙）

3、Sentinel 熔断功能实现

熔断规则：

10 秒内请求量超过 20 次

异常比例大于 50% 即熔断

熔断后 5 秒内直接拒绝请求（返回错误提示）

熔断后支持自动恢复（通过 Sentinel 的恢复机制）

4、日志与可视化

打印每次请求的日志，包括：

请求时间、线程名、耗时、是否被限流/熔断

**考察点：**

Sentinel 的 限流与熔断配置能力

高并发下服务稳定性设计

异常比例熔断机制的理解与实践

**三、模拟不当日志查看行为导致内存崩溃（踩坑式实验题）**

在实际生产环境中，不少开发者习惯使用 cat 命令直接查看大日志文件（如 cat xxx.log）。

然而，这种操作在日志文件较大（如几百 MB ～ 几 GB）时，极易导致服务器内存暴涨、

GC 频繁，甚至 OOM 崩溃，从而影响整台机器上的其他业务。

本题将模拟这一风险场景，让你亲身验证这种行为的危险性，并实现安全的替代方案。

友情提示：加入 -Xmx256m 参数模拟低内存环境更能体现问题

使用 Java 实现一个程序，包含以下两个功能：

1\. 构造一个模拟的大型日志文件

文件名：large.log

文件大小目标：≥ 500MB（可使用重复写入模拟）

示例内容（每行）：

2025-01-01 00:00:00 INFO User login success, userId=123

2025-01-01 00:00:01 ERROR Failed to connect to database

2\. 实现两种读取方式：

A. cat 风格：一次性读取整个文件到内存

使用 xx 或 xx 整体读取

输出前 10 行内容，统计耗时

捕获并记录 OOM 或异常

B. 分页流式读取：逐行读取 + 限制每次读取行数

使用 xx 按行读取

只读取前 N 行（如 N=1000），模拟日志查看

统计内存占用和耗时

3、对比分析并输出结果：

每种方式的：

耗时（毫秒）

内存使用情况（可用 xx 获取）

是否抛出异常

示例输出格式（控制台）：

[Method A] Total time: 3127 ms

[Method A] Peak memory: 750MB

[Method A] Exception: java.lang.OutOfMemoryError

[Method B] Total time: 143 ms

[Method B] Peak memory: 28MB

[Method B] Read lines: 1000

**四、自定义线程池任务调度模拟器**

你在设计一个高并发任务调度系统，需要批量处理用户任务。为了控制系统资源和提高吞吐

量，请你不依赖 Spring，而是 手动基于 ThreadPoolExecutor

1、实现一个完整的线程池模型，并观测和分析其运行过程。

每个任务模拟耗时 1~3 秒，随机打印任务 ID 和执行线程名

每秒会有 10 个任务被提交，持续提交 30 秒

总任务量：约 300 个

2、使用自定义的线程池执行这些任务

要求如下：

核心线程数：corePoolSize = 4

最大线程数：maximumPoolSize = 10

队列容量：workQueue = LinkedBlockingQueue(50)

拒绝策略使用：DiscardPolicy（丢弃）

打印：

线程池当前线程数量

活跃线程数量

已完成任务数

队列中等待任务数量

输出建议每秒打印一次状态信息，比如：

[Monitor] Pool size: 6, Active: 4, Completed: 128, Queue: 46

3、实现自定义线程工厂 + 拒绝策略

实现自定义线程工厂：线程名格式为 my-thread-%d

自定义拒绝策略：记录被拒绝的任务 ID 和拒绝时间到日志

4、任务统计

总共处理了多少任务？多少被拒绝？

平均任务执行耗时？

最大并发数是多少？线程数峰值是多少？

**考察点：**

ThreadPoolExecutor 使用与参数理解

自定义线程工厂和拒绝策略，以及被拒绝任务的 日志记录与统计

线程池监控与状态统计

**五、模拟实现一个 NIO RPC 服务框架（轻量版 Dubbo 通信模型）**

你正在构建一个类似 Dubbo 的轻量 RPC 框架，需要实现一个 NIO 通信模块用于替代

传统的阻塞 Socket 模型。你的任务是模拟实现一个 NIO 服务端和客户端，能够完成请

求/响应交互，并具备多客户端并发接入能力。

1、系统目标

使用 Java 原生 NIO 实现服务端和客户端

实现一个简单的 RPC 协议（基于文本或定长二进制协议）

服务端支持并发处理多个客户端请求，并返回响应

客户端可以并发发起请求并获取响应

2、功能细化

服务端要求：

使用 Selector 和 ServerSocketChannel

处理多个客户端连接

请求格式：

MathService|add|3,4

响应格式：

result=7

内部可用 Map<String, Object> 模拟服务注册，如：

services.put("MathService", new MathServiceImpl());

客户端要求：

使用 SocketChannel

支持多线程并发请求（如 10 个线程模拟 100 次调用）

打印每次请求的响应时间、结果

3、协议格式建议（文本协议）

请求：HelloService|sayHello|Tom

响应：result=Hello To m

可升级为 JSON 协议、或者定长二进制协议（模拟 Dubbo 序列化）

4、可选扩展

扩展点 内容说明

协议层抽象 将协议解码/编码解耦出专门类，模拟 Dubbo Codec

服务注册/发现模拟 通过本地 Map 模拟一个简单的注册中心

线程池处理请求 服务端业务逻辑使用线程池执行，提高并发性

超时/异常处理机制 客户端设置请求超时，模拟网络异常

**考察点：**

Java NIO Selector + Channel 网络模型

简单 RPC 协议设计与实现（文本协议）

多客户端并发连接处理

客户端 并发请求与响应解析

服务注册、方法映射与反射调用


